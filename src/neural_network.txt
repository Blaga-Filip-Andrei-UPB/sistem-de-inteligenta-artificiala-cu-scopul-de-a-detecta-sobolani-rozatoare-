#de facut: sa imi dau seama ce face codul asta acasa unde chiar am un ide pentru python

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.optimizers import Adam

# Setarea dimensiunii imaginii de intrare
IMG_SIZE = 256  # Dimensiunea imaginii (trebuie să fie aceeași cu dimensiunea de preprocesare)

# Crearea unui model CNN simplu
def create_cnn_model(input_shape=(IMG_SIZE, IMG_SIZE, 1)):  # 1 canal pentru imagini alb-negru
    model = Sequential()

    # Straturi convoluționale
    model.add(Conv2D(32, (3, 3), activation='relu', input_shape=input_shape))
    model.add(MaxPooling2D(pool_size=(2, 2)))

    model.add(Conv2D(64, (3, 3), activation='relu'))
    model.add(MaxPooling2D(pool_size=(2, 2)))

    model.add(Conv2D(128, (3, 3), activation='relu'))
    model.add(MaxPooling2D(pool_size=(2, 2)))

    # Aplatizarea imaginii pentru a o conecta la straturi dense
    model.add(Flatten())

    # Straturi dense
    model.add(Dense(128, activation='relu'))
    model.add(Dropout(0.5))  # Dropout pentru regularizare
    model.add(Dense(1, activation='sigmoid'))  # 1 neuron pentru clasificare binară (sobolan vs. nu sobolan)

    # Compilarea modelului
    model.compile(optimizer=Adam(learning_rate=0.0001), 
                  loss='binary_crossentropy', 
                  metrics=['accuracy'])

    return model

# Crearea modelului
model = create_cnn_model()

# Sumara arhitectura a modelului
model.summary()

# Crearea unui ImageDataGenerator pentru preprocesarea datelor și augmentare
train_datagen = ImageDataGenerator(rescale=1./255,  # Normalizare imagini
                                   rotation_range=20,  # Rotații aleatorii
                                   width_shift_range=0.2,  # Translații aleatorii pe orizontală
                                   height_shift_range=0.2,  # Translații aleatorii pe verticală
                                   shear_range=0.2,  # Tăiere aleatorie
                                   zoom_range=0.2,  # Zoom aleatoriu
                                   horizontal_flip=True,  # Flip pe orizontală
                                   fill_mode='nearest')  # Mod de umplere a pixelilor lipsă

test_datagen = ImageDataGenerator(rescale=1./255)  # Numai normalizare pentru setul de testare

# Seturile de date
train_dir = 'path_to_train_data'  # Calea către setul de date de instruire
validation_dir = 'path_to_validation_data'  # Calea către setul de date de validare

train_generator = train_datagen.flow_from_directory(
    train_dir,
    target_size=(IMG_SIZE, IMG_SIZE),
    color_mode='grayscale',  # Imagini alb-negru
    batch_size=32,
    class_mode='binary')  # Clasificare binară (sobolan / nu sobolan)

validation_generator = test_datagen.flow_from_directory(
    validation_dir,
    target_size=(IMG_SIZE, IMG_SIZE),
    color_mode='grayscale',  # Imagini alb-negru
    batch_size=32,
    class_mode='binary')  # Clasificare binară

# Antrenarea modelului
history = model.fit(
    train_generator,
    steps_per_epoch=train_generator.samples // 32,
    epochs=20,
    validation_data=validation_generator,
    validation_steps=validation_generator.samples // 32)

# Salvarea modelului antrenat
model.save('rat_detector_model.h5')
